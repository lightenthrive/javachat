## 如何看待设计模式，并简单说说你对观察者模式的理解

1、设计模式有神马用2、观察者模式类图及实现。

## 互联网分层架构的本质

不管是跨进程的分层架构，还是进程内的MVC分层，都是一个**“数据移动”**，然后**“被处理”**和**“被呈现”**的过程，归根结底一句话：互联网分层架构，是一个数据移动，处理，呈现的过程，其中**数据移动是整个过程的核心**。

数据处理和呈现要CPU计算，**CPU是固定不动的**：

- db/service/web-server都部署在固定的集群上
- 端上，不管是browser还是APP，也有固定的CPU处理

 **数据是移动的**：

- 跨进程移动：数据从数据库和缓存里，转移到service层，到web-server层，到client层
- 同进程移动：数据从model层，转移到control层，转移到view层

数据要移动，所以有两个东西很重要：

- 数据传输的格式
- 数据在各层次的形态

 先看**数据传输的格式**，即协议很重要：

- service与db/cache之间，二进制协议/文本协议是数据传输的载体
- web-server与service之间，RPC的二进制协议是数据传输的载体
- client和web-server之间，http协议是数据传输的载体

 再看**数据在各层次的形态**，以用户数据为例：

- db层，数据是以“行”为单位存在的row(uid, name, age)
- cache层，数据是以kv的形式存在的kv(uid -> User)
- service层，会把row或者kv转化为对程序友好的User对象
- web-server层，会把对程序友好的User对象转化为对http友好的json对象
- client层：最终端上拿到的是json对象

## 分层架构演进的核心原则与方法是什么？

- 让上游更高效的获取与处理数据，**复用**
- 让下游能屏蔽数据的获取细节，**封装**

 弄清楚这个原则与方法，再加上一些经验积累，就能回答网友经常在评论中提出的这些问题了：

- 是否需要引入DAO层，什么时机引入
- 是否需要服务化，什么时机服务化
- 是否需要抽取通用中台业务，什么时机抽取
- 是否需要前后端分离，什么时机分离

（网友们的这些提问，其实很难回答。在不了解业务发展阶段，业务规模，数据量并发量的情况下，妄下YES或NO的结论，本身就是不负责任的。）

## 假设服务器经常宕机，你从哪些方面去排查问题？

内存满，硬盘满，

## 你的接口服务数据被人截包了，你如何防止数据恶意提交？

答：我们可以在接口传输参数里面设置一个业务编号，这个编号用来区分是否重复提交。这样即使数据被抓包了，对方也无法区分每个字段你的含义，这时，这个业务编号的作用就来了。

## 高可用方案的设计

## 重构过代码没有？说说经验；

## 库存超发的原因是什么？

成功的购买流程是：读取库存，更新库存数据库，插入购买记录。如果多个线程同时更新数据库，就会把库存减到负数，从而超发。

解决方案把查询库存和插入购买记录放到一个事务中，加锁：

1. 读库存加悲观锁，查询数据库的时候在sql语句上加`for update`，阻塞效率低。
1. 不阻塞的乐观锁效率高。在表中加一个版本号字段，每次更新自增，读取记录后，修改时先检查版本号是否一致，不一致就回滚事务。由于高并发的时候，容易失败，所以引入重试机制。这样就引入了复杂性。
1. 把存储介质换成redis，lua脚本中实现业务逻辑。lua脚本本身是单线程的，等于自带悲观锁。然后要通过定时任务写入数据库，或者直接写入消息队列。redis要考虑高可用问题，由于把缓存作为主要功能实现，因此不适合大规模应用。

## [“ID串行化”是如何保证消息顺序性的？](https://mp.weixin.qq.com/s/4UB4AZe2R0lVCT6f5ExEMw)

## 一千万的用户实时排名如何实现；

## 五万人并发抢票怎么实现；

## 分布式事务



## 加好友和私信的计数类系统通知是推还是拉？

如果希望**实现不刷新网页，计数就实时变化**：登录时拉取，变化时推送新的计数。

**如果业务对此类通知的展现不需要这么实时**，完全可以通过拉取：只有在链接跳转，或者刷新网页时，才重新异步**拉取**最新的通知。

变化频率低，可以使用缓存。

